# 操作系统

## 内存管理

### 多级页表的概念

虚拟地址和物理地址的映射关系存储在页表中，而现在页表又是分级的。64位系统一般都是3~5级。常见的配置是4级页表，就以4级页表为例说明。分别是PGD、PUD、PMD、PTE四级页表。

在硬件上会有一个叫做页表基地址寄存器 cr3，它存储一级页表（PGD）的首地址。MMU 就是根据页表基地址寄存器从PGD 页表一路查到PTE，最终找到物理地址(PTE页表中存储物理地址)。

四级页表查找过程需要四次内存访问。延时可想而知，非常影响性能。

![](https://pic4.zhimg.com/80/v2-70f03a91b02fe51cced8cb57fa30d84b_720w.jpg)

### TLB 是缓存多级页表

TLB （translation lookaside buffer）其实就是一块高速缓存。数据cache缓存地址(虚拟地址或者物理地址)和数据。TLB缓存虚拟地址和其映射的物理地址。TLB根据虚拟地址查找cache，它没得选，只能根据虚拟地址查找。所以TLB是一个虚拟高速缓存。硬件存在TLB后，虚拟地址到物理地址的转换过程发生了变化。虚拟地址首先发往TLB确认是否命中cache，如果cache hit直接可以得到物理地址。否则，一级一级查找页表获取物理地址。并将虚拟地址和物理地址的映射关系缓存到TLB中。

> 参考 [知乎](https://zhuanlan.zhihu.com/p/108425561)

### 多级页表的优点

由于单级页表需要大片连续的空间，维护单级页表在存储上是奢侈和低效的。

多级页表的出现可以节约内存。多级页表常用四级页表，在内存中我们只用维护一个大小为 `4K` 的一级页表（页目录表，可以管理1024个二级页表），并通过cr3寄存器记录这个页表的首地址。当二级页表不在内存中时，可以通过缺页中断将目标二级页表交换进入内存。

> 参考 [知乎](https://www.jianshu.com/p/45fa8bd131be)

### 堆 栈 的生长方向

<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F905602%2F201611%2F905602-20161105231508236-898051085.png&refer=http%3A%2F%2Fimages2015.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660468814&t=0cf58e5ac9e59962fbe3aa66943e054c" alt="img" style="zoom:100%;" />

堆：生长方向是向上的，也就是向着内存地址增加的方向。

栈：生长方向是向下的，是向着内存地址减小的方向增长。

在内存中，堆栈公用全部自由空间，只不过各自的启始地址和增长方向不同，它们之间并没有一个固定的界限，如果在运行时“堆”和“栈”

## 操作系统基本特征原语

### 原语

原语强调的是  某个操作或者指令集合 的连续性和不可中断性；类似于数据库的事务，集合中的指令要么一个也不执行，要么全部执行

### 并发和并行的区别

1. 并发（concurrency）：并发是指宏观上在一段时间内能同时运行多个程序。
2. 并行（parallelism）：同一时刻能运行多个指令。
3. 操作系统通过引入进程和线程，使得程序能够并发运行。

### 共享

1. 系统中的资源可以被多个并发进程共同使用。
2. 共享分为**互斥共享**和**同时共享**。
3. 互斥共享的资源称为**临界资源**，需要用**同步机制**来实现**互斥访问**。

### 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

**多个进程能在同一个处理器上并发执行使用了时分复用技术**，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

**虚拟内存使用了空分复用技术**，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 异步

操作系统的异步性体现在三个方面：

一是进程的异步性，进程以人们不可预知的速度向 前推进。

二是程序的不可再现性，即程序执行的结果有时是不确定的。

三是程序执行时间的不可预知性，即每个程序何时执行，执行顺序以及完成时间是不确定的。

### 文件描述符

在每个进程的PCB中，有一个文件描述符数组。

一个文件描述符表可以存放多个文件描述符。

![文件描述符](https://img1.baidu.com/it/u=1214934545,2164114979&fm=253&fmt=auto&app=138&f=JPG?w=731&h=500)

前三个文件描述符默认是stdin stdout stderr, 并且默认是打开状态。

文件描述符表由内核维护

### 系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/tGPV0.png" alt="img" style="zoom:67%;" />

Linux 的系统调用

|   Task   | Commands                    |
| :------: | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
|   安全   | chmod(); umask(); chown();  |

## 宏内核和微内核

### 宏内核

宏内核是将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 微内核

由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。

在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的**性能损失**。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg)

## 中断分类

### 外中断

由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

### 异常

由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

### 系统调用

在用户程序中使用系统调用。

## 什么是内核态和用户态？

为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。

内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。

用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。

用户程序运行在用户态,操作系统内核运行在内核态。

## 如何实现内核态和用户态的切换？

处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。

1. 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。
2. 异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。
3. 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。

## 进程和线程

### 什么是进程？

进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。

进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。

上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。

进程一般由以下的部分组成：

1. 进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。
2. 程序段
3. 数据段

### 孤儿进程和僵尸进程?

**孤儿进程：** 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程：**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

**危害：**如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，因此孤儿进程并不会有什么危害。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。

> **僵尸进程处理方法：** [孤儿进程与僵尸进程[总结] - Rabbit_Dale - 博客园 (cnblogs.com)](https://www.cnblogs.com/Anker/p/3271773.html#:~:text=%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%88%B6%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%EF%BC%8C%E8%80%8C%E5%AE%83%E7%9A%84%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B%E8%BF%98%E5%9C%A8%E8%BF%90%E8%A1%8C%EF%BC%8C%E9%82%A3%E4%B9%88%E9%82%A3%E4%BA%9B%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%B0%86%E6%88%90%E4%B8%BA%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%82%20%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%B0%86%E8%A2%ABinit%E8%BF%9B%E7%A8%8B%28%E8%BF%9B%E7%A8%8B%E5%8F%B7%E4%B8%BA1%29%E6%89%80%E6%94%B6%E5%85%BB%EF%BC%8C%E5%B9%B6%E7%94%B1init%E8%BF%9B%E7%A8%8B%E5%AF%B9%E5%AE%83%E4%BB%AC%E5%AE%8C%E6%88%90%E7%8A%B6%E6%80%81%E6%94%B6%E9%9B%86%E5%B7%A5%E4%BD%9C%E3%80%82%20%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8fork%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%EF%BC%8C%E8%80%8C%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%B0%83%E7%94%A8wait%E6%88%96waitpid%E8%8E%B7%E5%8F%96%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%BB%8D%E7%84%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E3%80%82%20%E8%BF%99%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%A7%B0%E4%B9%8B%E4%B8%BA%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E3%80%82,3%E3%80%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8D%B1%E5%AE%B3%20unix%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E6%9C%BA%E5%88%B6%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E5%8F%AA%E8%A6%81%E7%88%B6%E8%BF%9B%E7%A8%8B%E6%83%B3%E7%9F%A5%E9%81%93%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9D%9F%E6%97%B6%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%EF%BC%8C%20%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E3%80%82%20%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6%E5%B0%B1%E6%98%AF%3A%20%E5%9C%A8%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9A%84%E6%97%B6%E5%80%99%2C%E5%86%85%E6%A0%B8%E9%87%8A%E6%94%BE%E8%AF%A5%E8%BF%9B%E7%A8%8B%E6%89%80%E6%9C%89%E7%9A%84%E8%B5%84%E6%BA%90%2C%E5%8C%85%E6%8B%AC%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%2C%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%89%E3%80%82)

### 什么是守护进程？

守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

守护进程是个特殊的**孤儿进程**，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了避免进程被任何终端所产生的信息所打断，其在执行过程中的信息也不在任何终端上显示。由于在 linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。

### 进程的基本操作

以Unix系统举例：

1. 进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程**用户级虚拟地址空间相同的(但是独立的)一份副本**，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。

   ```c
   pid_t fork(void);
   ```
2. 回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。

   ```c
   pid_t waitpid(pid_t pid, int *statusp, int options);
   ```
3. 加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。

   ```c
   int execve(const char *filename, const char *argv[], const char *envp[]);
   ```
4. 进程终止：

   ```c
   void exit(int status);
   ```

### 进程间通信

每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。

不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。

- 信号：异步通信，根据特定的情况发出信号量供其他进程相应。

- 管道：半双工消息传输，类似创建共享文件节点，进程双方读写该文件节点(传递字串)

- 消息队列：传递void*标识的数据，可以置界解析。每个消息队列都有自己的id，根据id可以拿到指定的数据。

- 共享内存：访问速度快，但读写同步需要信号量来控制

- socket通信：ip地址+端口，实现socket的网络传输。一个端口只能对应一个进程，但是一个进程可以绑定多个端口 https://www.csdn.net/tags/NtTaYg2sNzg4NDktYmxvZwO0O0OO0O0O.html

  https://www.cnblogs.com/LUO77/p/5816326.html

### 进程调度的时机

1. 当前运行的进程运行结束。
2. 当前运行的进程由于某种原因阻塞。
3. 执行完系统调用等系统程序后返回用户进程。
4. 在使用抢占调度的系统中，具有更高优先级的进程就绪时。
5. 分时系统中，分给当前进程的时间片用完。

### 不能进行进程调度的情况

1. 在中断处理程序执行时。
2. 在操作系统的内核程序临界区内。
3. 其它需要完全屏蔽中断的原子操作过程中。

### [进程的调度策略](https://blog.csdn.net/smile_zhangw/article/details/81910524)

- 先到先服务调度算法

​		利于长作业，不利于短作业。

- 短作业优先调度算法

​	选择就绪队列中确切（或估计）运行时间最短的进程进入执行。它既可采用可抢占调度方式，也可采用不可抢占调度方式。

​	有效降低作业的平均等待时间和提高系统的吞吐量。但是长进程可能饿死。

- 优先级调度算法

​	进程的优先级用于表示进程的重要性及运行的优先性。一个进程的优先级可分为两种：静态优先级和动态优先级。

- 时间片轮转调度算法

​	简单易行、平均响应时间短。此算法不利于处理紧急作业

​	时间片的大小可调整，如果时间片大到让一个进程足以完成其全部工作，这种算法就退化为FCFS调度算法；时间片大小的动态调整需要考虑就绪态进程个数、进程上下文切换开销、系统吞吐量、系统响应时间等多方面因素。

- 高响应比优先调度算法

​	$Rp=（等待时间+预计执行时间）/执行时间=响应时间/执行时间$

​	既考虑进程等待时间，又考虑进程的执行时间。 但HRRF调度算法需要每次计算各各个进程的响应比Rp，这会带来较大的时间开销

- 多级反馈队列调度算法

​		多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。



### 进程调度策略的基本设计指标

1. CPU利用率
2. 系统吞吐率，即单位时间内CPU完成的作业的数量。
3. 响应时间。
4. 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键

   + 平均周转时间
   + 带权周转时间
   + 平均带权周转时间

### 进程的状态与状态转换



<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20201230131645270.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660635962&t=77ab246b29565f7a299745ff0a971bc5" alt="五状态模型" style="zoom: 50%;" />

<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F2020121501330398.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzIyNjc0%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1660636133&t=4651f6d888fe0d7093478080f1fc879e" alt="七状态模型" style="zoom: 80%;" />



### 什么是线程？

1. 是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保证程序的实时性，实现进程内部的并发。
2. 线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。
3. 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件标识符和其他内核资源。

### 为什么需要线程？

线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：

1. 进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。
2. 进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。

引入线程就是为了解决以上进程的不足，线程具有以下的优点：

主要从三个方面来解释：资源大小、切换开销、通讯机制

1. 从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。
2. 从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。
3. 从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。

### 简述线程和进程的区别和联系

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。
2. 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3. 进程是资源分配的最小单位，线程是CPU调度的最小单位。
4. 通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信 `IPC`，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。
5. 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。【进程的优点】
6. 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。【进程的优点】
7. 进程适应于多核、多机分布；线程适用于多核。

### 进程和线程的基本API

进程API以Unix系统为例，线程相关的API属于Posix线程(Pthreads)标准接口。

| 进程原语  |       线程原语        |             描述             |
| :-------: | :-------------------: | :--------------------------: |
|  `fork`   |   `pthread_create`    |        创建新的控制流        |
|  `exit`   |    `pthread_exit`     |     从现有的控制流中退出     |
| `waitpid` |    `pthread_join`     |    从控制流中得到退出状态    |
| `atexit`  | `pthread_cancel_push` | 注册在退出控制流时调用的函数 |
| `getpid`  |    `pthread_self`     |        获取控制流的ID        |
|  `abort`  |   `pthread_cancel`    |    请求控制流的非正常退出    |

### 多线程模型

1. 多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。
2. 一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。
3. 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。

### 线程间通信的方式

1. 临界区：通过多线程的串行化来访问公共资源，速度快，适合控制数据访问。
2. 互斥量 `Synchronized/Lock`：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
3. 信号量 `Semphare`：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
4. 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 进程同步的方法

操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个进程来协同完成一些任务。
当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。
当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。
进程的同步方法：

[Linux 文件锁与记录锁_mb5fdb0f93c5ca2的技术博客_51CTO博客](https://blog.51cto.com/u_15060511/4336950)

1. 互斥锁
2. 读写锁
3. 条件变量
4. 记录锁(record locking)
5. 信号量
6. 屏障（barrier）

### 线程同步的方法

操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或是协作的线程设置同步点的问题时，需要使用一些线程同步的方法来解决这些问题。

线程同步的方法：

1. 互斥锁
2. 读写锁：**读写锁和互斥体类似，不过读写锁有更高的并行性，互斥体要么是锁住状态，要么是不加锁状态，而且一次只有一个线程可以对其加锁**。而读写锁可以有3个状态，**读模式下锁住状态，写模式下锁住状态，不加锁状态**。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占用读模式的读写锁。读写锁适合对数据结构读的次数远大于写的情况。
3. 条件变量
4. 信号量
5. 自旋锁：**自旋锁和互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）状态，自旋锁可用于下面的情况：锁被持有的时间短，并且线程不希望再重新调度上花费太多的成本**。自旋锁通常作为底层原语用于实现其他类型的锁。根据他们所基于的系统架构，可以通过使用测试并设置指令有效地实现。当然这里说的有效也还是会导致CPU资源的浪费：当线程自旋锁变为可用时，CPU不能做其他任何事情，这也是自旋锁只能够被只有一小段时间的原因。
6. 屏障（barrier）：屏障是用户协调多个线程并行工作的同步机制，屏障允许每个线程等待，直到所有合作的线程都到达某一点，然后从该点出继续执行。pthread_join其实就是一种屏障，允许一个线程等待，直到另一个线程退出。但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有线程达到屏障后可以继续工作。

### 进程同步与线程同步有什么区别

进程之间地址空间不同，不能感知对方的存在，**同步时需要将锁放在多进程共享的空间**。而线程之间共享同一地址空间，同步时把锁**放在所属的同一进程空间即可。**

### 死锁是怎样产生的？

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。
产生死锁需要满足下面四个条件：

​	**互斥**、**占由且等待**一些、**非抢占**、两个以上的进程/线程彼此**循环等待**

1. 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
2. 占有并等待条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。
3. 非抢占条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。
4. 循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。

### 如何解决死锁问题？

解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:

1. 资源一次性分配，这样就不会再有请求了（破坏请求条件）。
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。
3. 可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。
4. 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件



## 什么是虚拟地址，什么是物理地址？

地址空间是一个非负整数地址的有序集合。

在一个带虚拟内存的系统中，CPU 从一个有N=pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）,现代系统通常支持 32 位或者 64 位虚拟地址空间。

一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的M 个字节。

地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。

 一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。

 主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。

## 什么是虚拟内存？

为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：

1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其他进程破坏。

## 为什么要引入虚拟内存？

1. 虚拟内存作为缓存的工具

   + 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。
   + 虚拟内存利用DRAM缓存来自通常更大的虚拟地址空间的页面。
2. 虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。

   + **简化链接：** 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。

     + 例如：一个给定的 `linux`系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址）`0x400000`开始，数据段，代码段，栈，堆等等。
   + **简化加载：** 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们**标记为无效（未被缓存）** ，将页表条目指向目标文件的起始位置。

     + **加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。**
   + **简化共享：** 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。

     + 一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，**这样OS创建页表，将虚拟页映射到不连续的物理页面。**
     + 某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。**OS会把不同进程中适当的虚拟页面映射到相同的物理页面。**
   + **简化内存分配：** 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如 `malloc`），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，**因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中**。

+ 虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时，`MMU`会读一个 `PTE`，通过在 `PTE`上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。

## 常见的页面置换算法

当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：

+ 先进先出(FIFO)算法：

  + 思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。
  + 实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。
  + 特点：实现简单；性能较差，调出的页面可能是经常访问的
+ 最近最少使用（`LRU`）算法:

  + 思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。
  + 实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面
  + 特点：可能达到最优的效果，维护这样的访问链表开销比较大

当前最常采用的就是 `LRU`算法。

+ 最不常用算法（`Least Frequently Used, LFU`）

  + 思路：缺页时，置换访问次数最少的页面
  + 实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面
  + 特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换

## 请说一下什么是写时复制？

+ 如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。
+ 写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。
+ 在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。

## 实时操作系统的概念

实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。

## 优先级反转是什么？如何解决

由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。

目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。

1. 优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。
2. 优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。
